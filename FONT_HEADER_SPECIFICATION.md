# 한글 폰트 헤더 파일 형식 명세

## 개요

이 문서는 Arduino/ESP32용 한글 디스플레이 라이브러리에서 사용되는 `.h` 폰트 헤더 파일의 형식을 명확히 규정합니다.

## 1. 파일 구조

### 1.1 기본 구조

```cpp
/**
 * [폰트명] - Korean Hangul Font for Arduino/ESP32
 * 
 * Converted from EasyView font file: [원본파일명].han
 * Generated: [생성일시]
 * 
 * Font Structure:
 * - Glyph Size: 16x16 pixels
 * - Bytes per Glyph: 32 bytes
 * - Total Glyphs: 360
 * - Total Size: 11520 bytes
 * 
 * Glyph Layout:
 * - Cho (초성): 0~159 (20 chars x 8 bul)
 * - Jung (중성): 160~247 (22 chars x 4 bul)
 * - Jong (종성): 248~359 (28 chars x 4 bul)
 */

#ifndef [FONT_NAME]_H
#define [FONT_NAME]_H

#include "hangulDisp.h"

// Font bitmap data
const uint8_t [FontName]_Bitmaps[] PROGMEM = {
    // 비트맵 데이터 (11,520 바이트)
};

// Font information wrapper
const HangulFontInfo [FontName] = {
    "[Font Display Name]",  // name
    16,                     // width
    16,                     // height
    [FontName]_Bitmaps + 0,     // choData
    [FontName]_Bitmaps + 5120,  // jungData
    [FontName]_Bitmaps + 7936   // jongData
};

#endif // [FONT_NAME]_H
```

## 2. 상세 명세

### 2.1 비트맵 데이터 (`_Bitmaps` 배열)

#### 크기 및 구조
- **총 크기**: 11,520 바이트 (고정)
- **글리프 개수**: 360개
- **글리프당 크기**: 32 바이트
- **픽셀 크기**: 16×16 픽셀

#### 데이터 레이아웃
비트맵 데이터는 세 개의 섹션으로 구성됩니다:

| 섹션 | 오프셋 | 크기 | 글리프 수 | 설명 |
|------|--------|------|-----------|------|
| **초성 (Cho)** | 0 | 5,120 바이트 | 160개 | 20개 초성 × 8벌 |
| **중성 (Jung)** | 5,120 | 2,816 바이트 | 88개 | 22개 중성 × 4벌 |
| **종성 (Jong)** | 7,936 | 3,584 바이트 | 112개 | 28개 종성 × 4벌 |

#### 글리프 인덱싱
각 섹션 내에서 글리프는 **벌 우선 정렬**로 저장됩니다:

```
인덱스 = (벌 번호 × 자모 개수) + 자모 인덱스
```

**예시:**
- 초성 "ㄱ"의 1벌: `인덱스 0 = (0 × 20) + 0`
- 초성 "ㄱ"의 2벌: `인덱스 20 = (1 × 20) + 0`
- 중성 "ㅏ"의 1벌: `인덱스 0 = (0 × 22) + 0`

### 2.2 글리프 비트맵 형식

각 글리프는 **32 바이트**로 구성되며, 16×16 픽셀을 표현합니다.

#### 비트 순서
- **바이트 순서**: MSB First (Most Significant Bit First)
- **행 단위**: 각 행은 2바이트 (16비트)로 구성
- **총 16행**: 32 바이트

#### 비트맵 구조
```
행 0:  [바이트 0] [바이트 1]  (16비트 = 16픽셀)
행 1:  [바이트 2] [바이트 3]
행 2:  [바이트 4] [바이트 5]
...
행 15: [바이트 30] [바이트 31]
```

#### 픽셀 추출 예제
```cpp
// 특정 위치 (row, col)의 픽셀 읽기
uint16_t rowData = (glyph[row * 2] << 8) | glyph[row * 2 + 1];
bool pixel = (rowData & (0x8000 >> col)) != 0;
```

### 2.3 HangulFontInfo 구조체

```cpp
struct HangulFontInfo {
    const char* name;        // 폰트 표시 이름
    uint8_t width;           // 글리프 너비 (항상 16)
    uint8_t height;          // 글리프 높이 (항상 16)
    const uint8_t* choData;  // 초성 데이터 포인터
    const uint8_t* jungData; // 중성 데이터 포인터
    const uint8_t* jongData; // 종성 데이터 포인터
};
```

#### 포인터 오프셋 계산
```cpp
choData  = _Bitmaps + 0;      // 초성 시작 (오프셋 0)
jungData = _Bitmaps + 5120;   // 중성 시작 (160글리프 × 32바이트)
jongData = _Bitmaps + 7936;   // 종성 시작 (5120 + 88글리프 × 32바이트)
```

## 3. 자모 인덱스 규칙

### 3.1 초성 (Cho) - 20개 (인덱스 0~19)

| 인덱스 | 자모 | 인덱스 | 자모 | 인덱스 | 자모 | 인덱스 | 자모 |
|--------|------|--------|------|--------|------|--------|------|
| 0 | ㄱ | 5 | ㅁ | 10 | ㅇ | 15 | ㅋ |
| 1 | ㄲ | 6 | ㅂ | 11 | ㅈ | 16 | ㅌ |
| 2 | ㄴ | 7 | ㅃ | 12 | ㅉ | 17 | ㅍ |
| 3 | ㄷ | 8 | ㅅ | 13 | ㅊ | 18 | ㅎ |
| 4 | ㄸ | 9 | ㅆ | 14 | ㅋ | 19 | (빈 초성) |

**주의**: 인덱스 19는 초성이 없는 경우를 위한 빈 글리프입니다.

### 3.2 중성 (Jung) - 22개 (인덱스 0~21)

| 인덱스 | 자모 | 인덱스 | 자모 | 인덱스 | 자모 |
|--------|------|--------|------|--------|------|
| 0 | ㅏ | 7 | ㅖ | 14 | ㅝ |
| 1 | ㅐ | 8 | ㅗ | 15 | ㅞ |
| 2 | ㅑ | 9 | ㅘ | 16 | ㅟ |
| 3 | ㅒ | 10 | ㅙ | 17 | ㅠ |
| 4 | ㅓ | 11 | ㅚ | 18 | ㅡ |
| 5 | ㅔ | 12 | ㅛ | 19 | ㅢ |
| 6 | ㅕ | 13 | ㅜ | 20 | ㅣ |
|  |  |  |  | 21 | (빈 중성) |

**주의**: 인덱스 21은 중성이 없는 경우를 위한 빈 글리프입니다.

### 3.3 종성 (Jong) - 28개 (인덱스 0~27)

| 인덱스 | 자모 | 인덱스 | 자모 | 인덱스 | 자모 |
|--------|------|--------|------|--------|------|
| 0 | (받침없음) | 9 | ㅅ | 18 | ㅍ |
| 1 | ㄱ | 10 | ㅆ | 19 | ㅎ |
| 2 | ㄲ | 11 | ㅇ | 20 | ㄳ |
| 3 | ㄳ | 12 | ㅈ | 21 | ㄵ |
| 4 | ㄴ | 13 | ㅊ | 22 | ㄶ |
| 5 | ㄵ | 14 | ㅋ | 23 | ㄺ |
| 6 | ㄶ | 15 | ㅌ | 24 | ㄻ |
| 7 | ㄷ | 16 | ㅍ | 25 | ㄼ |
| 8 | ㄹ | 17 | ㅎ | 26 | ㄽ |
|  |  |  |  | 27 | ㄾ |

**주의**: 인덱스 0은 받침이 없는 경우입니다.

## 4. 벌 시스템

### 4.1 벌(Bul) 개념
벌은 초성, 중성, 종성의 **시각적 변형**으로, 한글의 조화로운 조합을 위한 것입니다.

### 4.2 벌 개수
- **초성**: 8벌 (0~7)
- **중성**: 4벌 (0~3)
- **종성**: 4벌 (0~3)

### 4.3 벌 선택 규칙
벌 선택은 `HangulCore` 네임스페이스의 룩업 테이블에 의해 자동으로 결정됩니다:

```cpp
// 초성 벌 = f(중성, 받침유무)
uint8_t choBul = getChosungBul(jung, hasJong);

// 중성 벌 = f(초성, 받침유무)
uint8_t jungBul = getJungsungBul(cho, hasJong);

// 종성 벌 = f(중성)
uint8_t jongBul = getJongsungBul(jung);
```

## 5. 명명 규칙

### 5.1 파일명
```
[폰트명]_kr.h
```
예: `H01_kr.h`, `Apple_kr.h`, `Goth00_kr.h`

### 5.2 변수명
```cpp
// 비트맵 배열
const uint8_t [폰트명]_kr_Bitmaps[] PROGMEM

// 폰트 정보 구조체
const HangulFontInfo [폰트명]_kr
```

### 5.3 헤더 가드
```cpp
#ifndef [대문자폰트명]_KR_H
#define [대문자폰트명]_KR_H
```

## 6. 메모리 최적화

### 6.1 PROGMEM 속성
모든 폰트 데이터는 **PROGMEM**으로 선언되어 플래시 메모리에 저장됩니다:

```cpp
const uint8_t FontName_Bitmaps[] PROGMEM = { ... };
```

### 6.2 메모리 사용량
- **각 폰트**: 11,520 바이트 (플래시)
- **런타임**: 포인터만 사용 (12바이트)

## 7. 사용 예제

### 7.1 폰트 헤더 포함
```cpp
#include "hangulDisp.h"
#include "fonts/H01_kr.h"
```

### 7.2 폰트 설정
```cpp
hangulDisp display(drawPixelCallback);
display.setFont(H01_kr);
```

### 7.3 텍스트 출력
```cpp
display.print(10, 30, "한글 출력 테스트", TFT_WHITE);
```

## 8. 변환 도구

### 8.1 han_to_h.py
EasyView `.han` 파일을 `.h` 헤더로 변환하는 Python 스크립트입니다.

```bash
python tools/han_to_h.py input.han output.h
```

### 8.2 변환 프로세스
1. `.han` 파일 읽기 (11,520 바이트)
2. 바이트 배열을 C 배열 형식으로 변환
3. `HangulFontInfo` 구조체 생성
4. `.h` 파일 저장

## 9. 검증

### 9.1 파일 크기 검증
```python
assert len(bitmap_data) == 11520, "비트맵 데이터는 정확히 11,520바이트여야 합니다"
```

### 9.2 구조 검증
- 초성 섹션: 5,120 바이트 (바이트 0~5119)
- 중성 섹션: 2,816 바이트 (바이트 5120~7935)
- 종성 섹션: 3,584 바이트 (바이트 7936~11519)

## 10. 호환성

### 10.1 플랫폼
- Arduino AVR
- Arduino Mega
- ESP32
- ESP8266
- STM32

### 10.2 컴파일러
- GCC 4.8 이상
- Arduino IDE 1.8.0 이상
- PlatformIO

## 11. 제한사항

### 11.1 고정 크기
- 모든 폰트는 16×16 픽셀로 고정
- 가변 폭 폰트는 지원하지 않음

### 11.2 비트맵 전용
- 벡터 폰트 미지원
- 안티앨리어싱 미지원

## 12. 버전 이력

- **v1.0** (2026-02-06): 초기 명세 작성
- 한글 전용 폰트 형식 확정
- 135개 폰트 변환 완료

---

**문서 버전**: 1.0  
**최종 수정**: 2026년 2월 6일  
**작성자**: Hangul Display Library Team
